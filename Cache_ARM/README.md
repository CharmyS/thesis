To run the benchmark

    $ ./runall.sh

The "runall.sh" script is the preferred way to compile benchmarks, run the
tests, collect the data, and plot the results. 
 
You will need matplotlib installed to graph results. The 'open' command is also
used, which only works on OSX (comment it out otherwise). 
 
Set the desired tests to use through the $TEST variable in the script. If
$RUN_LOCAL is set to 1, the tests will run on the local machine.  Otherwise,
you can provide the IP addresses in $remote_hosts to run the tests remotely
(set up loginless login for best results).  You will also need to get the
corresponding $architecture(s) variable to specify the target ISA.


------------------------------------------------------------------------------
## More Controlled Way to Run Tests
------------------------------------------------------------------------------

How to Run the "caches" benchmark: 

    $ cd thesis/Cache_ARM
    $ make clean; make
    $ ./run_test.py -i large
    $ open plots/caches.pdf

This runs the "caches" benchmark using the "large" input set (see input.txt for
other set types). Data is written to the ./report/report.txt file (actually, a
generated report file based on the current timestamp is used). If matplotlib is
installed, ./run_test.py will also plot the results to a *.pdf file.


If the data is collected on a machine without matplotlib, you can plot the data
by copying the report.txt file to a machine with matplotlib, and then running
./run_test.py using the "-n" flag ("no-run"). 

    laptop$ cd thesis/Cache_ARM
    laptop$ scp $LINUX_BOX:~/thesis/Cache_ARM/report/report.txt ./report/report.txt
    labtop$ ./run_test.py -n
    laptop$ open plots/caches.pdf

You can feed it a specific report file using "-r my_report_name.txt". 

Use the "-h" flag to ./run_test.py to learn about some of its other options,
which includes specialized annotations for some processors. 
                                                             
------------------------------------------------------------------------------
## Building and Executing ccbench on non-x86 ISAs
------------------------------------------------------------------------------

The ccbench suite currently supports benchmarking processors (or emulators)
running the following ISAs: x86, ARM, Tilera's TILE64, and UCB's RISC-V. 

The easiest method is to use the "runall.sh" top-level script and specify the
machine under the $architecture(s) variable (x86, arm, tile64, riscv). This
drives the Makefile to compile the benchmark as appropriate and supplies the
run_test.py script with the appropriate "-a" flag to invoke the proper target
machine. 

To add your own, new architecture (or to specialize your compiler/invocation
settings), make of a copy of one of the directories in $CCBENCH/arch and
change as needed. For example, you may want to use a different compiler with
its own set of compiler flags, even when running on a particular x86 machine.
Second, modify $CCBENCH/common/Makefile.tests to invoke your new architecture's
Makefile fragment. No modifications are required to the python run_test.py
scripts.

By default, a "generic" architecture setting is used in which gcc is called to
compile the benchmark.  The benchmark is then executed directly on the machine.
This will work for both x86 and ARM. However, to get more specific compiler
flags (as well as for targets that require cross-compiling), it is recommended
that you specify exactly the desired target architecture.
  

------------------------------------------------------------------------------
## Important Files
------------------------------------------------------------------------------

  - run_tests.py        - main CLI program to run and plot tests. Python 
                            code that invokes C code through bash. Found inside
                            each micro-benchmark directory, and customized to
                            plot data for the given micro-benchmark. 
  - common/             - Contains code shared by all tests.
                            Includes a pthreads barrier implementation for
                            platforms that do not natively support
                            pthreads_barrier_t (i.e., OS X), and an abstracted
                            clock interface.
  - common/Makefile.tests - Main makefile used by all ukernels.
  - reports/report.txt  - Auto-generated by run_tests.py. Stores the
                            results of all of the runs from its latest
                            invocation (actual name is auto-generated and 
                            involves the current timestamp).
  - plots/              - Contains plots generated by run_tests.py
  - input.txt           - Contains input sets used by run_tests.py

 
------------------------------------------------------------------------------
## Current Micro-benchmarks And What They Measure
------------------------------------------------------------------------------

  - caches       - cache sizes, access latencies (pointer chase)
  - cache2cache  - cache-to-cache latency, bandwidth (ping pong arrays 
                    between threads)
  - band_req     - number of outstanding requests (pointer chase with 
                    multiple streams).
  - band_req_mc  - machine total bandwidth (pointer chase with 
                    multiple streams, with multiple threads)
  - strided      - strided memory acccesses: cache sizes, access latencies. 
                    Mostly ineffectual due to prefetching.
  - peakflops    - Prints out max flops of the machine. Does NOT plot 
                    anything (and so doesn't fit within the normal flow 
                    of runall.sh, etc.). Saves results to results.txt file.
  - incluexclu   - figure out if a LLC is inclusive (one thread runs out of 
                    L1, the other thread attempts to blow out the LLC). 
                    (Very experimental, not recommended for use).
  - mem_interleaving- preliminary attempt to measure best interleaving of 
                    multiple threads with different memory distances between 
                    threads (very experimental, not recommended for use).

  

